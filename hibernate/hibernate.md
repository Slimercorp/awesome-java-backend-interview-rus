[Оглавление](../README.md)

# Hibernate


## Что такое Hibernate Framework?
__Hibernate Framework__ - это фреймворк для языка Java, который предоставляет возможности для работы с базами данных, используя концепцию объектно-реляционного отображения (ORM). Hibernate позволяет разработчикам работать с базами данных, используя объектно-ориентированный подход, что делает код более читабельным и понятным. Hibernate Framework автоматически создает SQL-запросы для доступа к данным в базе данных, основываясь на маппинге объектов на таблицы в базе данных. Это позволяет разработчикам избежать написания сложного SQL-кода вручную и ускоряет процесс разработки. Hibernate также предоставляет множество дополнительных функций, таких как кэширование запросов, поддержка транзакций и т.д.

## Что Такое ORM?
__ORM__ является аббревиатурой для “Object-related Mapping” или “Объектно-реляционного Отображения”. Концепция, которая позволяет работать с таблицами базы данных как с объектами. Это философия, цель которой, сделать доступ и управление данными настолько простым, насколько это возможно. Достигается это путём отображения объектов в соответствии с их данными. Это самый основной концепт, на котором построен Hibernate и который отличает его от Java (объектно-ориентированного языка программирования).

## Какие важные преимущества дает использование Hibernate Framework?
+ Hibernate позволяет разработчику избежать написания большинства SQL запросов (они уже реализованы , вам надо просто использовать методы которые предоставляет фреймворк), что снижает вероятность ошибок при работе с базами данных..
+ Под бортом у Hibernate есть куча полезных инструментов которые значительно ускоряют работу приложения, самыми примечательными из них являются двухуровневое кэширования и тонкие настройки lazy и fetch изъятия.
+ Сам генерирует таблицы в базу данных.
+ Hibernate устраняет множество спагетти кода (повторяющегося), который постоянно преследует разработчика при работе с JDBC. Скрывает от разработчика множество кода, необходимого для управления ресурсами и позволяет сосредоточиться на бизнес логике.
+ Hibernate поддерживает XML так же как и JPA аннотации, что позволяет сделать реализацию кода независимой.
+ Hibernate предоставляет собственный мощный язык запросов (HQL), который похож на SQL. Стоит отметить, что HQL полностью объектно-ориентирован и понимает такие принципы, как наследование, полиморфизм и ассоциации (связи).
+ Hibernate легко интегрируется с другими Java EE фреймворками, например, Spring Framework поддерживает встроенную интеграцию с Hibernate.
+ Hibernate поддерживает ленивую инициализацию используя proxy объекты и выполняет запросы к базе данных только по необходимости.
+ Hibernate поддерживает разные уровни cache, а следовательно может повысить производительность.
+ Важно, что Hibernate может использовать чистый SQL, а значит поддерживает возможность оптимизации запросов и работы с любым сторонним вендором БД и его фичами.

## Какие преимущества Hibernate над JDBC?
Hibernate имеет ряд преимуществ перед JDBC API:

+ Hibernate удаляет множество повторяющегося кода из JDBC API, а следовательно его легче читать, писать и поддерживать.
+ Hibernate поддерживает наследование, ассоциации и коллекции, что не доступно в JDBC API.
+ Hibernate неявно использует управление транзакциями. Большинство запросов нельзя выполнить вне транзакции. При использовании JDBC API для управления транзакциями нужно явно использовать `commit` и `rollback`.
+ JDBC API throws SQLException, которое относится к проверяемым исключениям, а значит необходимо постоянно писать множество блоков try-catch. В большинстве случаев это не нужно для каждого вызова JDBC и используется для управления транзакциями. Hibernate оборачивает исключения JDBC через непроверяемые JDBCException или HibernateException, а значит нет необходимости проверять их в коде каждый раз. Встроенная поддержка управления транзакциями в Hibernate убирает блоки try-catch.
+ Hibernate Query Language (HQL) более объектно ориентированный и близкий к Java язык запросов, чем SQL в JDBC.
+ Hibernate поддерживает кэширование, а запросы JDBC — нет, что может понизить производительность.
+ Конфигурация Hibernate позволяет использовать JDBC вроде соединения по типу JNDI DataSource для пула соединений. Это важная фича для энтерпрайз приложений, которая полностью отсутствует в JDBC API.
+ Hibernate поддерживает аннотации JPA, а значит код является переносимым на другие ORM фреймворки, реализующие стандарт, в то время как код JDBC сильно привязан к приложению.

## Какие ключевые интерфейсы использует Hibernate?
+ __Session interface__ (org.hibernate.Session) — однопоточный короткоживущий объект, который предоставляет связь между объектами приложения и базой данных. Это основной инструмент, используемый для создания, выдачи и выполнения SQL и HQL-запросов. Он оборачивает JDBC java.sql.Connection и работает как фабрика для org.hibernate.Transaction. Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования. Сессия в Hibernate не поточно-ориентированная. Это означает, что каждый отдельный поток, связанный с Сессией, должен создавать и использовать свой собственный “экземпляр Сессии”, обеспечив его защиту после завершения работы.Экземпляр Session является интерфейсом между кодом в java приложении и hibernate framework и предоставляет методы для операций CRUD.
Обьект Session можно получить из SessionFactory :
```java
Session session = sessionFactory.openSession();
```
+ __SessionFactory interface__ (org.hibernate.SessionFactory) — неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных. Именно из объекта SessionFactory мы получаем объекты типа Session. На все приложение существует только одна SessionFactory и она инициализируеться вместе со стартом приложения. SessionFactory кэширует мета-дату и SQL запросы которые часто используются приложением во время работы. Так же оно кэширует информацию которая была получена в одной из транзакций и может быть использована и в других транзакциях.
Обьект SessionFactory можно получить следующим обращением:
```java
SessionFactory sessionFactory = configuration.buildSessionFactory();
```
+ __Configuration interface__ - при запуске приложения Hibernate пытается считать данные из конфигурационного файла, и на его основе создает объект Configuration, что бы считать эту информацию, a SessionFactory создается уже на основе Configuration;
+ __Transaction interface__ (org.hibernate.Transaction) — однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC или JTA транзакций. org.hibernate.Session может занимать несколько org.hibernate.Transaction в определенных случаях.;
+ __Query and Criteria interfaces__ - это два интерфейса в Hibernate, которые используются для выполнения запросов к базе данных и получения объектов из таблиц.
        + Query - это интерфейс, который предоставляет методы для создания и выполнения запросов на языке HQL (Hibernate Query Language), который является аналогом SQL-запросов. Он позволяет разработчикам выполнять сложные запросы к базе данных, фильтровать данные и сортировать их по заданным критериям. Query также поддерживает параметризованные запросы, что позволяет избежать SQL-инъекций и улучшить безопасность приложения.
        + Criteria - это еще один интерфейс, который позволяет разработчикам создавать запросы на языке Criteria API, который является типобезопасной альтернативой HQL. Criteria API позволяет строить запросы с помощью методов Java, что делает их более читаемыми и понятными. Он также поддерживает фильтрацию, сортировку и параметризацию запросов.

## Каков Синтаксис Для Создания SQL Запроса?
Для создания SQL-запроса в Hibernate, вам нужно будет использовать данный код:
`Session.createSQLQuery`

## Что такое конфигурационный файл Hibernate?
Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации `SessionFactory`. В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте, что поможет hibernate выбрать режим работы с конкретной базой данных.

## Какие есть способы конфигурации работы с Hibernate?
Существует четыре способа конфигурации работы с Hibernate :
+ используя аннотации;
+ `hibernate.cfg.xml`;
+ `hibernate.properties`;
+ `persistence.xml`.

Самый частый способ конфигурации : через аннотации и файл `persistence.xml`, что касается файлов `hibernate.properties` и `hibernate.cfg.xml`, то `hibernate.cfg.xml` главнее (если в приложение есть оба файла, то принимаются настройки из файла `hibernate.cfg.xml`). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для разных баз данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.

## Что такое Hibernate mapping file?
Файл отображения (mapping file) используется для связи entity бинов и колонок в таблице базы данных. В случаях, когда не используются аннотации JPA, файл отображения .xml может быть полезен (например при использовании сторонних библиотек).
Hibernate mapping file - это XML-файл, который описывает отображение (mapping) между объектами Java и таблицами в базе данных, а также между свойствами объектов и столбцами таблиц. Hibernate использует этот файл для создания соответствующих таблиц в базе данных, а также для генерации SQL-запросов при работе с этими таблицами.
Hibernate mapping file описывает, как каждый класс и его свойства соотносятся с таблицами и столбцами базы данных. Файл содержит информацию о классе, его свойствах и типах данных, которые они должны хранить, а также о таблицах и столбцах базы данных, которые должны использоваться для хранения этих данных. Это отображение позволяет Hibernate автоматически создавать соответствующие таблицы в базе данных и выполнять CRUD-операции (create, read, update, delete) на этих таблицах.

## Назовите некоторые важные аннотации, используемые для отображения в Hibernate.
Hibernate поддерживает как аннотации из JPA, так и свои собственные, которые находятся в пакете org.hibernate.annotations. Наиболее важные аннотации JPA и Hibernate:
+ __@Entity__: используется для указания класса как entity bean.
+ __@Table__: используется для определения имени таблицы из БД, которая будет отображаться на entity bean.
+ __@Access__: определяет тип доступа, поле или свойство. Поле — является значением по умолчанию и если нужно, чтобы hibernate использовал методы getter/setter, то их необходимо задать для нужного свойства.
+ __@Id__: определяет primary key в entity bean.
+ __@EmbeddedId__: используется для определения составного ключа в бине.
+ __@Column__: определяет имя колонки из таблицы в базе данных.
+ __@GeneratedValue__: задает стратегию создания основных ключей. Используется в сочетании с javax.persistence.GenerationType enum.
+ __@OneToOne__: задает связь один-к-одному между двумя сущностными бинами. Соответственно есть другие аннотации OneToMany, ManyToOne и ManyToMany.
+ __@Cascade__: определяет каскадную связь между двумя entity бинами. Используется в связке с org.hibernate.annotations.CascadeType.
+ __@PrimaryKeyJoinColumn__ (или просто @JoinColumn): определяет внешний ключ для свойства. Используется вместе с org.hibernate.annotations.GenericGenerator и org.hibernate.annotations.Parameter.
+ __@JoinTable__: дает понять Hibernat'у какая таблица являетя связывающей в отношении Many-to-Many, ее можно писать в любой сязываемой таблице, разницы нет, т.к.  в связи Many-to-Many нет owning side и не одна из сущностей не владеет внешним ключом.
+ __@Enumerated__: указывает, что поле является Enum, в аргументах можно задать способ сохранения enum в таблице: по умолчанию используется ORDINAL - сохраняет индекс enum'а; STRING - сохраняет строку - название enum'а в таблицу.
+ __@Transient__ : исключает поле из сериализации.

## Что вы знаете о Hibernate SessionFactory и как его сконфигурировать?
`SessionFactory` является фабрикой классов и используется для получения объектов `session`. `SessionFactory` отвечает за считывание параметров конфигурации Hibernate и подключение к базе данных. Обычно в приложении имеется только один экземпляр `SessionFactory` и потоки, обслуживающие клиентские запросы, получают экземпляры `session` с помощью объекта `SessionFactory`. Внутреннее состояние `SessionFactory` неизменно (immutable). Internal state (внутреннее состояние) включает в себя все метаданные об Object/ Relational Mapping и задается при создании `SessionFactory`.
Он потокобезопасный. Множество потоков может обращаться к одному объекту одновременно.
`SessionFactory` также предоставляет методы для получения метаданных класса и статистики, вроде данных о втором уровне кэша, выполняемых запросах и т.д.

## Как получить Hibernate Session и что это такое?
Объект Hibernate `Session` является связью между кодом java приложения и hibernate. Это основной интерфейс для выполнения операций с базой данных. Жизненный цикл объекта session связан с началом и окончанием транзакции. Этот объект предоставляет методы для CRUD (create, read, update, delete) операций для объекта персистентности. С помощью этого экземпляра можно выполнять HQL, SQL запросы и задавать критерии выборки. Объект Hibernate `Session` не является потокобезопасным. Каждый поток должен иметь свой собственный объект `Session` и закрывать его по окончанию.

## В чем разница между `openSession` и `getCurrentSession`?
Hibernate `SessionFactory getCurrentSession()` возвращает сессию, связанную с контекстом. Но для того, чтобы это работало, нам нужно настроить его в конфигурационном файле hibernate. Так как этот объект session связан с контекстом hibernate, то отпадает необходимость к его закрытию. Объект session закрывается вместе с закрытием SessionFactory.
```xml
<property name="hibernate.current_session_context_class">thread</property>
```
Метод Hibernate `SessionFactory openSession()` всегда создает новую сессию. Мы должны обязательно контролировать закрытие объекта сеанса по завершению всех операций с базой данных. Для многопоточной среды необходимо создавать новый объект session для каждого запроса.
Существует еще один метод `openStatelessSession()`, который возвращает session без поддержки состояния. Такой объект не реализует первый уровень кэширования и не взаимодействует с вторым уровнем. Сюда же можно отнести игнорирование коллекций и некоторых обработчиков событий. Такие объекты могут быть полезны при загрузке больших объемов данных без удержания большого кол-ва информации в кэше.

## Что собой являет коллекция типа Bag и зачем она используется?
Своей реализации тип коллекции Bag очень напоминает Set, разница состоит в том, что Bag может хранить повторяющиеся значения. Bag хранит непроиндексированный список элементов. Большинство таблиц в базе данных имеют индексы отображающие положение элемента данных один относительно другого, данные индексы имеют представление в таблице в виде отдельной колонки. При объектно-реляционном маппинге, значения колонки индексов мапится на индекс в Array, на индекс в List или на key в Map. Если вам надо получить коллекцию объектов не содержащих данные индексы, то вы можете воспользоваться коллекциями типа Bag или Set (коллекции содержат данные в неотсортированном виде, но могут быть отсортированы согласно запросу).
Коллекция типа Bag в Hibernate - это коллекция, которая представляет собой множество элементов без упорядоченности, но может содержать дублирующиеся элементы. Она обеспечивает возможность хранения коллекции объектов в базе данных в отношении один-ко-многим или многие-ко-многим.
Bag обеспечивает поддержку повторяющихся элементов и сохранение порядка вставки элементов. Она может использоваться для представления множества объектов, которые могут дублироваться в базе данных. Bag может быть полезен, когда необходимо хранить коллекцию объектов, которые могут быть связаны с другими объектами в базе данных. Он может быть использован в отношении один-ко-многим или многие-ко-многим, где каждый элемент в коллекции является связанным объектом.

Bag имеет следующие свойства:
+ Она не гарантирует упорядоченность элементов.
+ Она может содержать дублирующиеся элементы.
+ Она поддерживает сохранение порядка вставки элементов.

## Какая разница между методами Hibernate Session `get()` и `load()`?
Hibernate session обладает различными методами для загрузки данных из базы данных. Наиболее часто используемые методы для этого — `get()` и `load()`.
+ `get()` загружает данные сразу при вызове, в то время как `load()` использует прокси объект и загружает данные только тогда, когда это требуется на самом деле. В этом плане `load()` имеет преимущество в плане ленивой загрузки данных.
+ `load()` бросает исключение, когда данные не найдены. Поэтому его нужно использовать только при уверенности в существовании данных.
+ Нужно использовать метод `get()`, если необходимо удостовериться в наличии данных в БД.

+ Метод `load()` обычно используется когда в не уверен что запрашиваемый объект уже находится в базе данных. Если объект не найден, то метод кидает исключение Если объект найден — метод возвращает прокси объект, который является ссылкой на объект находящийся в базе данных (запрос в базу данных еще не был осуществлен, своего рода lazy изъятие), непосредственный запрос к базе данных когда мы непосредственно обращаемся к необходимому объекту через прокси объект.
+ Метод `get()` используется тогда, вы на 100 процентов не уверены есть ли запрашиваемый объект в базе данных. В случае обращение к несуществующему объекту, метод `get()` вернет null. В случае нахождения объект, метод `get()` вернет сам объект и запрос в базу данных будет произведен немедленно.

## Что вы знаете о кэшировании в Hibernate? Объясните понятие кэш первого уровня в Hibernate?
Hibernate использует кэширование, чтобы сделать наше приложение быстрее. Кэш Hibernate может быть очень полезным в получении высокой производительности приложения при правильном использовании. Идея кэширования заключается в сокращении количества запросов к базе данных.

Кэш первого уровня Hibernate связан с объектом `Session`. Кэш первого уровня у Hibernate  включен по умолчанию и не существует никакого способа, чтобы его отключить. Однако Hibernate предоставляет методы, с помощью которых мы можем удалить выбранные объекты из кэша или полностью очистить кэш.
Любой объект закэшированный в session не будет виден другим объектам session. После закрытия объекта сессии все кэшированные объекты будут потеряны.
Кэш первого уровня (Session Cache) в Hibernate - это кэш, который находится внутри объекта Session. Он сохраняет данные только для текущей сессии и автоматически удаляет их, когда сессия закрывается. Кэш первого уровня представляет собой коллекцию объектов, которые были извлечены из базы данных в рамках текущей сессии. Hibernate автоматически сохраняет все изменения, внесенные в объекты, в кэш первого уровня, поэтому они могут быть применены в базе данных при вызове метода `commit()`.
Кэш первого уровня может улучшить производительность приложения, поскольку позволяет избежать повторных запросов к базе данных для объектов, которые были уже получены в текущей сессии. Он также позволяет автоматически применять изменения в базе данных, что уменьшает количество запросов к базе данных и улучшает производительность.
Однако кэш первого уровня имеет следующие ограничения:
+ Он доступен только в рамках текущей сессии и не может быть использован в других сессиях.
+ Он не может быть использован в распределенных приложениях или при работе с несколькими экземплярами приложения, поскольку он сохраняется в памяти JVM.
+ Он может занимать большой объем памяти, если сохраняет большое количество объектов.

## Какие существуют различные состояния у entity bean?
+ __Transient__: состояние, при котором объект никогда не был связан с какой-либо сессией и не является персистентностью. Этот объект находится во временном состоянии. Объект в этом состоянии может стать персистентным при вызове метода `save()`, `persist()` или `saveOrUpdate()`. Объект персистентности может перейти в transient состоянии после вызова метода `delete()`. Объект пока никак не связан с Hibernate и не отслеживается им (не находится в так называемом Persistence context). Вызов сеттеров на объекте никак не будут влиять на состояние БДю Можно воспринимать объект, находящийся в Trancient состоянии как обычный Java объектю
+ __Persistent__: когда объект связан с уникальной сессией он находится в состоянии persistent (персистентности). Любой экземпляр, возвращаемый методами `get()` или `load()` находится в состоянии persistent. Java объект становится Persistent тогда, когда он сохраняется с помощью Hibernate (метод `save()`) - следующий `commit()` сохранит объект в базе данных. Объект стоновится Persistent тогда, когда мы получаем его из базы данных (с помощью метода `get()`). Объект является Persistent когда он находится в Persistence context и отслеживатеся Hibernate. Persistence context - пространство, в котором находятся Java объекты, которые отслеживаются Hibernate. Объект находится в этом состоянии до тех пор, пока работает Hibernate сессия. Вызов сеттеров на Persistent объектах генерирует SQL код.
+ __Detached__: если объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится в отвязанном (detached) состоянии. Он покинул Persistence context, снова стал обычным Java объектом, который Hibernate не отслеживает. Это состояние достигается с поимощью вызова метода `detach()` или когда закрывается Hibernate сессия. Такой объект можно сделать персистентным используя методы `update()`, `saveOrUpdate()`, `lock()` или `replicate()`. Состояния transient или detached так же могут перейти в состояние persistent как новый объект персистентности после вызова метода `merge()`. 
+ __Removed__: объект получен для удаления и следующий `commit()` удалит соответствующую строку в таблице.

## Как используется вызов метода Hibernate Session merge()?
Hibernate `merge()` может быть использован для обновления существующих значений, однако этот метод создает копию из переданного объекта сущности и возвращает его. Возвращаемый объект является частью контекста персистентности и отслеживает любые изменения, а переданный объект не отслеживается.
Метод `merge()` в Hibernate используется для слияния (merge) состояний объектов, которые находятся вне текущей сессии, с объектами, находящимися внутри текущей сессии. Этот метод позволяет объединить два разных состояния объектов, которые могут содержать разные значения полей, в одно состояние объекта с обновленными значениями полей.

Метод `merge()` можно использовать в следующих ситуациях:
+ Объект был получен вне текущей сессии и нуждается в слиянии с объектом, который находится внутри текущей сессии.
+ Объект был изменен вне текущей сессии и должен быть сохранен в базе данных.

## В чем разница между Hibernate `save()`, `saveOrUpdate()` и `persist()`?
+ Hibernate `save()` используется для сохранения сущности в базу данных. Проблема с использованием метода `save()` заключается в том, что он может быть вызван без транзакции. А следовательно если у нас имеется отображение нескольких объектов, то только первичный объект будет сохранен и мы получим несогласованные данные. Также `save()` немедленно возвращает сгенерированный идентификатор (первичный ключ). Из библиотеки Hibernate (есть только в нем, нет в других JPA библиотеках). Гарантирует, что идентификатор будет определен сразу после вызова метода, т.к. `save()` должен что-то вернуть, он назначает id (если стратегия IDENTITY).
+ Hibernate `persist()` аналогичен `save()` с транзакцией. `persist()` не возвращает сгенерированный идентификатор сразу. Из спецификации JPA - любой JPA провайдер будет иметь этот метод. Ничего не возвращает. Значение первичного ключа выставится, но не обязательно сразу.
+ Hibernate `saveOrUpdate()` использует запрос для вставки или обновления, основываясь на предоставленных данных. Если данные уже присутствуют в базе данных, то будет выполнен запрос обновления. Метод `saveOrUpdate()` можно применять без транзакции, но это может привести к аналогичным проблемам, как и в случае с методом `save()`.

## Что произойдет, если будет отсутствовать конструктор без аргументов у Entity Bean?
Hibernate использует рефлексию для создания экземпляров Entity бинов при вызове методов `get()` или `load()`. Для этого используется метод `Class.newInstance()`, который требует наличия конструктора без параметров. Поэтому, в случае его отсутствия, вы получите ошибку HibernateException.

## В чем разница между sorted collection и ordered collection? Какая из них лучше?
При использовании алгоритмов сортировки из Collection API для сортировки коллекции используется сортированный список (sorted list). Для маленьких коллекций это не приводит к излишнему расходу ресурсов, но на больших коллекциях это может привести к потере производительности и ошибкам OutOfMemory. Так же entity бины должны реализовывать интерфейс `Comparable` или `Comparator` для работы с сортированными коллекциями.
При использовании фреймворка Hibernate для загрузки данных из базы данных мы можем применить Criteria API и команду `order by` для получения отсортированного списка (ordered list). Ordered list является лучшим выбором к sorted list, т.к. он использует сортировку на уровне базы данных. Она быстрее и не может привести к утечке памяти. Пример запроса к БД для получения ordered list:
```java
List<Employee> empList = session.createCriteria(Employee.class).addOrder(Order.desc("id")).list();
```
Разница между Sorted Collection и Ordered Collection заключается в том, как они упорядочивают свои элементы.
+ Sorted Collection - это коллекция, которая автоматически сортирует элементы в порядке возрастания или убывания на основе их значений. Она использует компаратор или естественный порядок элементов для сортировки элементов. Примерами Sorted Collection в Hibernate являются `SortedSet` и `TreeSet`.
+ Ordered Collection - это коллекция, которая сохраняет порядок элементов в том же порядке, в котором они были вставлены. Она не изменяет порядок элементов при вставке или удалении элементов из коллекции. Примерами Ordered Collection в Hibernate являются `List` и `ArrayList`.

## Как реализованы Join’ы Hibernate?
Существует несколько способов реализовать связи в Hibernate.
+ Использовать ассоциации, такие как one-to-one, one-to-many, many-to-many.
+ Использовать в HQL запросе команду JOIN. Существует другая форма «join fetch«, позволяющая загружать данные немедленно (не lazy).
+ Использовать чистый SQL запрос с командой join.

## Почему мы не должны делать Entity class как final?
Хибернейт использует прокси классы для ленивой загрузки данных (т.е. по необходимости, а не сразу). Это достигается с помощью расширения entity bean и, следовательно, если бы он был final, то это было бы невозможно. Ленивая загрузка данных во многих случаях повышает производительность, а следовательно важна.

## Какие есть способы получения данных в Hibernate?
Можно выделить 3 группы, с помощью которых можно работать с данными:
+ __Criteia API__:
    + Использование объектов вместо написания SQL (ОПП ориентированный вариант);
    + Многие ошибки предотвращаются на этапе компиляцции (type safe);
    + Не совсем интуитивный API;
    + Из-за сложного API возможна громоздкость кода.
+ __HQL (Hibernate Query Language)__:
    + Если вам удобнее работать с SQL, чем с объектами;
    + Работает с persistent objects, а не с таблицами БД;
    + Легче для чтения;
    + В JPA используется JPQL - Java Persistence Query Language (HQL - более расширенный вариант JPQL);
    + В конечном итоге преобразуется в нужный SQL формат, согласно диалекту СУБД;
    + Похож на обычный SQL.
+ __Native SQL__:
    + Обычные SQL запросы как при JDBC;
    + Самостоятельно нужно соблюдать диалект СУБД;
    + Не универсальный как HQL;
    + Работает с таблицами базы данных, а не с persistent objects.

## Что вы знаете о HQL и какие его преимущества?
Hibernate Framework поставляется с мощным объектно-ориентированным языком запросов — Hibernate Query Language (HQL). Он очень похож на SQL, за исключением, что в нем используются объекты вместо имен таблиц, что делает язык ближе к объектно-ориентированному программированию.
HQL является регистронезависимым, кроме использования в запросах имен java переменных и классов, где он подчиняется правилам Java. Например, SelECt то же самое, что и select, но ru.javastudy.MyClass отличен от  ru.javastudy.MyCLASS. Запросы HQL кэшируются (это как плюс так и минус).

## Что такое Query Cache в Hibernate?
Hibernate реализует область кэша для запросов resultset, который тесно взаимодействует с кэшем второго уровня Hibernate. Для подключения этой дополнительной функции требуется несколько дополнительных шагов в коде. Query Cache полезны только для часто выполняющихся запросов с повторяющимися параметрами. Для начала необходимо добавить эту запись в файле конфигурации Hibernate:
```xml
<property name="hibernate.cache.use_query_cache">true</property>
```
Уже внутри кода приложения для запроса применяется метод setCacheable(true), как показано ниже:
```java
Query query = session.createQuery("from Employee");
query.setCacheable(true);
query.setCacheRegion("ALL_EMP");
```

## Можем ли мы выполнить нативный запрос SQL (sql native) в Hibernate?
С помощью использования SQLQuery можно выполнять чистый запрос SQL. В общем случае это не рекомендуется, т.к. вы потеряете все преимущества HQL (ассоциации, кэширование). Выполнить можно примерно так:
```java
Transaction tx = session.beginTransaction();
SQLQuery query = session.createSQLQuery("select emp_id, emp_name, emp_salary from Employee");
List<Object[]> rows = query.list();
for(Object[] row : rows){
    Employee emp = new Employee();
    emp.setId(Long.parseLong(row[0].toString()));
    emp.setName(row[1].toString());
    emp.setSalary(Double.parseDouble(row[2].toString()));
    System.out.println(emp);
}
```

## Назовите преимущества поддержки нативного SQL в Hibernate.
Использование нативного SQL может быть необходимо при выполнении запросов к некоторым базам данных, которые могут не поддерживаться в Hibernate. Примером может служить некоторые специфичные запросы и «фишки» при работе с БД от Oracle.

## Что такое Named SQL Query?
Hibernate поддерживает именованный запрос, который мы можем задать в каком-либо центральном месте и потом использовать его в любом месте в коде. Именованные запросы поддерживают как HQL, так и Native SQL. Создать именованный запрос можно с помощью JPA аннотаций `@NamedQuery`, `@NamedNativeQuery` или в конфигурационном файле отображения (mapping files).

## Какие преимущества Named SQL Query?
Именованный запрос Hibernate позволяет собрать множество запросов в одном месте, а затем вызывать их в любом классе. Синтаксис Named Query проверяется при создании session factory, что позволяет заметить ошибку на раннем этапе, а не при запущенном приложении и выполнении запроса. Named Query глобальные, т.е. заданные однажды, могут быть использованы в любом месте.
Однако одним из основных недостатков именованного запроса является то, что его очень трудно отлаживать (могут быть сложности с поиском места определения запроса).

## Расскажите о преимуществах использования Hibernate Criteria API.
Hibernate Criteria API является более объектно-ориентированным для запросов, которые получают результат из базы данных. Для операций update, delete или других DDL манипуляций использовать Criteria API нельзя. Критерии используются только для выборки из базы данных в более объектно-ориентированном стиле.

Вот некоторые области применения Criteria API:
+ Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде `sum()`, `min()`, `max()` и т.д.
+ Criteria API может использовать `ProjectionList` для извлечения данных только из выбранных колонок.
+ Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы `createAlias()`, `setFetchMode()` и `setProjection()`.
+ Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод `add()` с помощью которого добавляются ограничения (Restrictions).
+ Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода `addOrder()`.

## Lazy and Eager loading
Связанные сущности подгрузятся сразу же :
```java
@OneToMany(mappedBy = "owner", fetch = FetchType.EAGER)
    private List<Item> items;
```
Связанные сущности загрузятся только по запросу (при вызове геттера например) :
```java
@OneToMany(mappedBy = "owner", fetch = FetchType.LAZY)
    private List<Item> items;
```
FetchType по умолчанию, когда не указываем явно как в примерах выше :
+ `@OneToMany`      Lazy
+ `@ManyToOne`      Eager
+ `@ManyToMany`     Lazy
+ `@OneToOne`       Eager

Lazy loading используется там, где загружаются много объектов.
Eager loading используется там, где загружается один объект

Для того, что бы подгружать связаные сущности при ленивой загрузке, в Hibernate есть специальный метод `initialize()`. Он используется что бы явно указать, что мы действительно хотим их подгрузить:
```java
Hibernate.initialize(person.getItems());
```

## Что вы знаете о Hibernate прокси и как это помогает в ленивой загрузке (lazy load)?
Hibernate Proxy - это объект, который создается Hibernate для ленивой загрузки ассоциированных объектов в коллекциях или связанных сущностях. Это означает, что объекты будут загружены только тогда, когда к ним будет обращение, а не сразу при загрузке основной сущности.
Использование Hibernate Proxy позволяет уменьшить количество запросов к базе данных и улучшить производительность приложения при работе с большими объемами данных.
Hibernate использует прокси-объекты, чтобы обеспечить ленивую загрузку связанных объектов. Когда объект основной сущности загружается из базы данных, все связанные сущности и коллекции могут быть заменены на прокси-объекты, которые не загружают данные из базы данных, а лишь запоминают информацию о том, как и когда нужно загрузить связанные объекты.

## Как реализованы отношения в Hibernate?
Реализовать отношение one-to-one, one-to-many, many-to-many можно с помощью JPA аннотаций или конфигурирования xml файла.
Для управления отношениями в Hibernate используются различные аннотации, такие как `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`. В зависимости от типа отношения и стратегии доступа к данным, Hibernate может автоматически создавать таблицы, связывающие объекты, и выполнять соответствующие операции чтения и записи в базу данных.
Hibernate также предоставляет возможность настройки каскадных операций, таких как сохранение, обновление или удаление связанных объектов при выполнении операций с основными объектами. Это позволяет управлять целостностью данных и сделать работу с базой данных более эффективной.

## Как управлять транзакциями с помощью Hibernate?
Hibernate вообще не допускает большинство операций без использования транзакций. 
В Hibernate транзакция обычно создается с помощью объекта `Session` от `SessionFactory`, который является фабрикой для получения объектов-сущностей и контекстом выполнения транзакций.

Существуют два способа управления транзакциями в Hibernate:
+ __Programmatic Transaction Management__ (Программное управление транзакциями) - это способ управления транзакциями, при котором транзакции управляются вручную с помощью объекта Session и методов начала, фиксации и отката транзакции. Пример использования программного управления транзакциями:
```java
Session session = sessionFactory.openSession();
Transaction transaction = null;
try {
    transaction = session.beginTransaction();
    // выполнение операций чтения и записи
    transaction.commit();
} catch (Exception e) {
    if (transaction != null) {
        transaction.rollback();
    }
    e.printStackTrace();
} finally {
    session.close();
}
```

+ __Declarative Transaction Management__ (Декларативное управление транзакциями) - это способ управления транзакциями, при котором транзакции управляются автоматически с помощью специальных аннотаций или XML-конфигурации. Пример использования декларативного управления транзакциями:
```java
@Transactional
public void doSomething() {
    // выполнение операций чтения и записи
}
```
Hibernate также предоставляет возможность настройки уровня изоляции транзакций, оптимизации выполнения транзакций и управления каскадными операциями. Это позволяет сделать работу с базой данных более эффективной и безопасной.
В целом, управление транзакциями в фреймворке выполнено гораздо лучше, чем в JDBC, т.к. мы не должны полагаться на возникновение исключения для отката транзакции. Любое исключение автоматически вызовет `rollback()`.

## Что такое каскадные связи (обновления) и какие каскадные типы есть в Hibernate?
Каскадные связи (или каскадное обновление) - это механизм в Hibernate, позволяющий автоматически обновлять, удалять или сохранять связанные объекты при выполнении операций над основными объектами. Таким образом, при изменении объекта, связанные с ним объекты также могут быть автоматически изменены без явного вызова методов для каждого из них. Вот пример кода с использованием аннотации `@Cascade`:
```java
import org.hibernate.annotations.Cascade;
 
@Entity
@Table(name = "EMPLOYEE")
public class Employee {
 
@OneToOne(mappedBy = "employee")
@Cascade(value = org.hibernate.annotations.CascadeType.ALL)
private Address address;
 
}
```
Обратите внимание, что есть некоторые различия между enum CascadeType в Hibernate и в JPA. Поэтому обращайте внимание какой пакет вы импортируете при использовании аннотации и константы типа. Наиболее часто используемые CascadeType перечисления:
+ __None__: без Cascading. Формально это не тип, но если мы не указали каскадной связи, то никакая операция для родителя не будет иметь эффекта для ребенка.
+ __ALL__: при выполнении операций сохранения, обновления и удаления связанных объектов также будут выполнены соответствующие операции над основным объектом. Все операции, которые будут произволитьс над родителем, будут автоматически каскадироваться на зависимые сущности.
+ __PERSIST__: при выполнении операций сохранения связанные объекты также будут сохранены в базе данных.
+ __SAVE_UPDATE__: Cascades save и update. Доступно только для hibernate. При выполнении операций сохранения и обновления связанные объекты также будут сохранены или обновлены в базе данных.
+ __MERGE__: при выполнении операций обновления связанные объекты также будут обновлены в базе данных.
+ __REMOVE__: при выполнении операций удаления связанные объекты также будут удалены из базы данных.
+ __DETACH__: при выполнении операций открепления (detach) связанные объекты также будут откреплены от текущего Persistance context сессии Hibernate.
+ __REFRESH__: при выполнении операций обновления (refresh) связанные объекты также будут обновлены в соответствии с базой данных.
+ __DELETE__: передает в Hibernate native DELETE действие. Только для hibernate.
+ __LOCK__: передает в Hibernate native LOCK действие.
+ __REPLICATE__: передает в Hibernate native REPLICATE действие.

## Как логировать созданные Hibernate SQL запросы?
Для логирования запросов SQL добавьте в файл конфигурации Hibernate строчку:
```xml
<property name="hibernate.show_sql">true</property>
```
Теперь все SQL запросы будут выводиться  консоль.
Отметьте, что это необходимо использовать на уровне Development или Testing и должно быть отключено в продакшн.
Так же можно логировать с помощью log4j. Эта библиотека позволяет логировать SQL запросы разными способами : вывод в консоль, файл и т.д. Подробнее будет рассмотрена далее.

## Как добавить логирование log4j в Hibernate приложение?
+ Добавить зависимость log4j в проект:
```xml
        implementation 'org.apache.logging.log4j:log4j-core:2.14.1
        implementation 'org.apache.logging.log4j:log4j-api:2.14.1
```
где 2.14.1 - версия
+ Создать log4j.xml или log4j.properties файл и добавить его в classpath (папка resources).
+ Для веб приложений используйте `ServletContextListener`, а для автономных приложений `DOMConfigurator` или `PropertyConfigurator` для настройки логирования.
+ Создайте экземпляр org.apache.log4j.Logger и используйте его согласно задачи.

## Как использовать JNDI DataSource сервера приложений с Hibernate Framework?
В веб приложении лучше всего использовать контейнер сервлетов для управления пулом соединений. Поэтому лучше определить JNDI ресурс для `DataSource` и использовать его в веб приложении. Для этого в Hibernate нужно удалить все специфичные для базы данных свойства и использовать указания свойства JNDI DataSource:
```xml
<property name="hibernate.connection.datasource">java:comp/env/jdbc/MyLocalDB</property>
```

## Как интегрировать Hibernate и Spring?
Лучше всего прочитать о настройках на сайтах фреймворков для текущей версии. Оба фреймворка поддерживают интеграцию из коробки и в общем настройка их взаимодействия не составляет труда. Общие шаги выглядят следующим образом.

+ Добавить зависимости для `hibernate-entitymanager`, `hibernate-core` и `spring-orm`.
+ Настроить конфигурационный файл Spring (смотрите в офф. документации или из примера на этом сайте).
    Суть заключается в следующих шагах:
    + Добавляем классу две аннотации:
        `@PropertySource("classpath:hibernate.properties")` - указывает путь до файла конфигурации.
        `@EnableTransactionManagment` - нужна что бы Spring управлял транзакциями.
    + Добавляем классу еще одно поле `Environment environment` из пакета `org.springframework.core.env`. С помощью объекта `Environment` запрашиваем конфиграцию из файла `hibernate.properties`. У  `Environment` еть метод `getRequiredProperty()` - именно он вытаскивает конфигурацию из файлов.
    + Добавляем метод, который получает конфигурацию из `hibernate.properties`, которая относится к самому Hibernate - необязательное действие.
    + Добавляем бин создания `SessionFactory` для работы с БД. Указываем путь до entity классов. Это обычный `SessionFactory`, но теперь он будет создаваться с помощью Spring.
    + Добавляем бин для автоматического упарвления транзакциями.
+ Создать классы модели и передать реализации DAO операции над базой данных. Важно, что DAO классы используют `SessionFactory`, который внедряется в конфигурации бинов Spring.
+ Дополнительно появляется возможность использовать аннотацию `@Transactional` и перестать беспокоиться об управлении транзакцией Hibernate. `@Transactional(readOnly=true)` - помечает метод, котрый только читает информацию из БД, не изменяет ее.

## Что вы знаете о классе HibernateTemplate?
Spring Framework предоставляет различные подходы для интеграции с Hibernate. Тем не менее, мы наиболее часто будем использовать подход, использующий `HibernateTemplate`. Есть две основные причины:
+ Класс скрывает детали управления сессиями и транзакциями.
+ Предоставляет подход основанный на шаблонах
`HibernateTemplate` класс скрывает трудности управления сессиями и транзакциями при использовании Hibernate для доступа к данным. Нужно только инициализировать `HibernateTemplate` путем передачи экземпляра `SessionFactory`. Spring Framework берет на себя беспокойство за детали связанные с сессиями и транзакциями. Это помогает устранить инфраструктурный код, который может вносить суматоху при увеличении сложности.
`HibernateTemplate`, так же как и `JdbcTemplate`, предоставляет шаблонный подход для доступа к данным. Когда вы используете `HibernateTemplate`, вы будете работать с callbacks. Обратные вызовы — это единственный механизм в шаблонном подходе, который уведомляет шаблон запускать нужную задачу. Преимущество наличия обратного вызова в том, что там только одна точка входа в слой доступа к данным. И эта точка входа определяется шаблоном, в этом случае `HibernateTemplate`.

Использование `HibernateTemplate` не явлется рекомендуемым. Вместо использования `HibernateTemplate` из пакета `org.springframework.orm` рекомендуется использовать декларативный подход (`@Transactional`). Таким образом фреймворк сам позаботится об операциях `open`, `commit`, `close`, `flush`.

## Какие паттерны применяются в Hibernate?
Hibernate применяет несколько паттернов проектирования для реализации своей функциональности:
+ __Object-Relational Mapping (ORM)__ - это паттерн, который позволяет связывать объекты приложения с таблицами базы данных. Hibernate использует ORM для автоматической генерации SQL-запросов на основе метаданных объектов приложения.
+ __Data Access Object (DAO)__ - это паттерн, который используется для абстрагирования работы с базой данных от остальной части приложения. Hibernate позволяет легко создавать DAO-объекты для доступа к базе данных и выполнения операций чтения и записи.
+ __Session-per-request__ - это паттерн, который рекомендуется для управления сессиями Hibernate в многопользовательских приложениях. Согласно этому паттерну, для каждого запроса создается отдельная сессия Hibernate, которая затем закрывается после выполнения запроса.
+ __Lazy Loading__ - это паттерн, который используется для отложенной загрузки связанных объектов. Hibernate позволяет использовать ленивую загрузку для минимизации числа SQL-запросов, которые должны быть выполнены для получения данных.
+ __Proxy__ - это паттерн, который используется для создания объектов-заместителей, которые могут быть использованы вместо реальных объектов до их фактического создания. Hibernate использует прокси-объекты для реализации ленивой загрузки.
+ __Identity Map__ - это паттерн, который используется для сохранения объектов в памяти, чтобы избежать повторного создания объектов. Hibernate использует Identity Map для хранения объектов, полученных из базы данных, чтобы избежать повторных запросов.
+ __Unit of Work__ - это паттерн, который используется для группировки операций чтения и записи в базу данных в рамках одной транзакции. Hibernate использует Unit of Work для управления транзакциями и обеспечения целостности данных в базе данных.
Эти паттерны помогают Hibernate достичь высокой производительности, удобства использования и расширяемости, что делает его одним из наиболее популярных инструментов для работы с базами данных в Java-приложениях.

## Расскажите о Hibernate Validator Framework.
Hibernate Validator Framework - это фреймворк валидации данных, который предоставляет механизмы для проверки и ограничения значений объектов в соответствии с определенными правилами. Он использует аннотации для определения правил валидации и может проверять значения объектов как на стороне клиента, так и на стороне сервера.
Основные возможности Hibernate Validator Framework:
+ Поддержка аннотаций - Hibernate Validator Framework использует аннотации для определения правил валидации. Это позволяет удобно определять правила валидации для объектов приложения.
+ Предварительно определенные аннотации - Hibernate Validator Framework предоставляет набор предварительно определенных аннотаций для проверки различных типов данных, таких как строки, числа, электронные адреса и др.
+ Создание пользовательских аннотаций - Hibernate Validator Framework позволяет создавать пользовательские аннотации для проверки объектов с использованием специфических для приложения правил валидации.
+ Настраиваемость - Hibernate Validator Framework предоставляет механизмы настройки правил валидации, такие как определение приоритетов, группирование и отключение определенных правил.
+ Интеграция с другими фреймворками - Hibernate Validator Framework интегрируется с другими фреймворками, такими как Spring и Struts, что обеспечивает легкую интеграцию в различные приложения.

Hibernate Validator Framework является очень полезным инструментом для проверки данных в Java-приложениях. Он позволяет удобно определять правила валидации для объектов и обеспечивает высокую степень настраиваемости.

Проверка данных является неотъемлемой частью любого приложения. Hibernate Validator обеспечивает эталонную реализацию двух спецификаций JSR-303 и JSR-349 применяемых в Java. Для настройки валидации в Hibernate необходимо сделать следующие шаги.
+ Добавить hibernate validation зависимости в проект.
```xml
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>1.1.0.Final</version>
</dependency>
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.1.1.Final</version>
</dependency>
```
+ Так же требуются зависимости из JSR 341, реализующие Unified Expression Language для обработки динамических выражений и сообщений о нарушении ограничений.
```xml
<dependency>
    <groupId>javax.el</groupId>
    <artifactId>javax.el-api</artifactId>
    <version>2.2.4</version>
</dependency>
<dependency>
    <groupId>org.glassfish.web</groupId>
    <artifactId>javax.el</artifactId>
    <version>2.2.4</version>
</dependency>
```
+ Использовать необходимые аннотации в бинах.
```java
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import org.hibernate.validator.constraints.CreditCardNumber;
import org.hibernate.validator.constraints.Email;
 
public class Employee {

    @Min(value=1, groups=EmpIdCheck.class)
    private int id;
     
    @NotNull(message="Name cannot be null")
    @Size(min=5, max=30)
    private String name;
     
    @Email
    private String email;
     
    @CreditCardNumber
    private String creditCardNumber;
 ```
## Что такое плагина Hibernate Tools Eclipse? И какие преимущества он дает?
Hibernate Tools - это набор плагинов для среды разработки Eclipse, предназначенный для упрощения работы с Hibernate. Эти плагины позволяют автоматически создавать объекты-сущности на основе существующей базы данных, генерировать код для выполнения операций чтения и записи данных, создавать маппинг-файлы и SQL-запросы, а также многие другие функции.
Преимущества использования Hibernate Tools в Eclipse:
+ Удобство использования - Hibernate Tools предоставляет удобный интерфейс для работы с Hibernate, что позволяет легко и быстро создавать объекты-сущности, генерировать SQL-запросы и маппинг-файлы.
+ Автоматическое создание кода - Hibernate Tools позволяет автоматически генерировать код для выполнения операций чтения и записи данных. Это сокращает время разработки и уменьшает вероятность ошибок при создании кода вручную.
+ Интеграция с базой данных - Hibernate Tools позволяет подключаться к базе данных из Eclipse и просматривать структуру таблиц, создавать объекты-сущности на основе таблиц, генерировать маппинг-файлы и SQL-запросы.
+ Поддержка разных версий Hibernate - Hibernate Tools поддерживает разные версии Hibernate, что позволяет работать с новыми и устаревшими версиями фреймворка.
+ Расширяемость - Hibernate Tools предоставляет API для создания пользовательских плагинов и интеграции с другими инструментами.
Hibernate Tools является очень полезным инструментом для работы с Hibernate в Eclipse. Он позволяет упростить разработку приложений на основе Hibernate и ускорить процесс создания кода для выполнения операций чтения и записи данных.

## Что вы знаете о проблеме N + 1?
Проблема N + 1 - это типичная проблема, связанная с выполнением запросов в базу данных при использовании ORM-фреймворков, включая Hibernate. Эта проблема возникает, когда при запросе объектов из базы данных, сначала выполняется один запрос для получения списка объектов, а затем для каждого объекта в этом списке выполняется еще один запрос для получения связанных данных.
Например, если у нас есть класс `Order` и связанный класс `Customer`, который хранит информацию о клиенте, оформившем заказ, то при выполнении запроса на получение списка заказов (например, `SELECT * FROM orders`), для каждого заказа будет выполнен дополнительный запрос на получение информации о клиенте (например, `SELECT * FROM customers WHERE id = ?`).
Когда в приложении много таких запросов, это может привести к значительному снижению производительности и увеличению времени выполнения запросов к базе данных.
Существует несколько способов решения проблемы N + 1, включая:
+ Использование метода `FetchType.EAGER` вместо `FetchType.LAZY` для определения типа загрузки связанных данных. Таким образом, данные будут загружаться сразу вместе с основным запросом.
+ Использование `JOIN FETCH` для связанных данных в основном запросе, чтобы избежать дополнительных запросов.
+ Использование пакетной загрузки (batch loading) для загрузки связанных данных пакетами, что позволяет снизить количество запросов к базе данных.
+ Использование кэша для связанных данных, чтобы избежать повторного выполнения запросов.
+ Оптимизация запросов, например, с помощью использования индексов и т.д.
В целом, проблема N + 1 - это распространенная проблема при работе с ORM-фреймворками, но ее можно решить с помощью различных методов оптимизации запросов и настройки ORM-фреймворка.

Рассмотри пример проблемы N + 1 с решение через `JOIN FETCH`:
![image](https://user-images.githubusercontent.com/116163780/235339561-af62f762-1063-4ad2-b36c-758d3e74fb7e.png)
![image](https://user-images.githubusercontent.com/116163780/235339640-7a1fa34e-beab-46b0-8667-36690bd3357b.png)
![image](https://user-images.githubusercontent.com/116163780/235340279-0e493291-d4cc-4723-b8d3-949bc9b4e840.png)
где `LEFT JOIN FETCH` не просто объединяет таблицы, но еще и кеширует данные из таблицы items.
В консоли видим, что был сделан только один запров к БД.
Что бы люди при выводе не повторялись, полученный resultSet поместим в Set:
![image](https://user-images.githubusercontent.com/116163780/235340636-fc192fd7-94e9-4f47-9041-cf04b8eaba43.png)

## Best Practices в Hibernate.
При использовании фреймворка Hibernate рекомендуется придерживаться некоторых правил.

+ Всегда проверяйте доступ к primary key. Если он создается базой данных, то вы не должны иметь сеттера.
+ По умолчанию hibernate устанавливает значения в поля напрямую без использования сеттеров. Если необходимо заставить хибернейт их применять, то проверьте использование аннотации `@Access(value=AccessType.PROPERTY)` над свойством.
+ Если тип доступа — property, то удостоверьтесь, что аннотация используется с геттером. Избегайте смешивания использования аннотации над обоими полями и геттером.
+ Используйте нативный sql запрос только там, где нельзя использовать HQL.
+ Используйте ordered list вместо сортированного списка из Collection API, если вам необходимо получить отсортированные данные.
+ Применяйте именованные запросы разумно — держите их в одном месте и используйте только для часто применяющихся запросов. Для специфичных запросов пишите их внутри конкретного бина.
+ В веб приложениях используйте JNDI DataSource вместо файла конфигурации для соединения с БД.
+ Избегайте отношений многие-ко-многим, т.к. это можно заменить двунаправленной One-to-Many и Many-to-One связью.
+ Для collections попробуйте использовать Lists, maps и sets. Избегайте массивов (array), т.к. они не дают преимуществ ленивой загрузки.
+ Не обрабатывайте исключения, которые могут откатить транзакцию и закрыть сессию. Если это проигнорировать, то Hibernate не сможет гарантировать, что состояние в памяти соответствует состоянию персистентности (могут быть коллизии данных).
+ Применяйте шаблон DAO для методов, которые могут использоваться в entity бинах.
+ Предпочитайте ленивую выборку для ассоциаций.
